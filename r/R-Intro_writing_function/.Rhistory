knitr::opts_chunk$set(echo = TRUE)
args(cor)
library(dplyr)
# Update the function so heads have probability p_head
toss_coin <- function(n_flips, p_head) {
coin_sides <- c("head", "tail")
# Define a vector of weights
weights <- c(p_head, 1-p_head)
# Modify the sampling to be weighted
sample(coin_sides, n_flips, replace = TRUE, prob = weights)
}
# Generate 10 coin tosses
toss_coin(10,0.8)
knitr::opts_chunk$set(echo = TRUE)
args(set.seed)
args(prop.test)
library(dplyr)
library(EnvStats)
propTestMdd(200,600,power = 0.9)
propTestMdd(200,600,power = 0.8)
?propTestMdd
propTestMdd(n1 = 200, n2 = 600, p2 = 0.52, power = 0.8)
propTestMdd(n1 = 600, n2 = 200, p0 = 0.52, power = 0.8)
propTestMdd(n = 600, n2 = 200, p0 = 0.52, power = 0.8)
propTestMdd(n = 600, n2 = 200, p2 = 0.52, power = 0.8)
propTestMdd(200,600,0.52, power = 0.8)
propTestMdd(800,200,0.52, power = 0.8)
propTestMdd(800,600,0.52, power = 0.8)
propTestMdd(n1=600,n2=200,p2=0.52)
propTestMdd(n1=600,n2=200,p2=0.52,sample.type = "two.sample")
propTestMdd(200,600,0.52)
propTestMdd(600,200,0.52)
propTestMdd(200,600,0.52)
propTestMdd(200,600,0.52,power = 0.8)
propTestMdd(200,600,0.52,power = 0.9)
propTestMdd(600,200,0.52,power = 0.9)
propTestMdd(600,200,0.52,power = 0.8)
propTestMdd(600,200,0.52,power = 0.8,two.sided.direction = "less")
propTestMdd(200,600,0.52,power = 0.8,two.sided.direction = "less")
propTestMdd(200,600,0.52,power = 0.8)
propTestMdd(600,200,0.52,power = 0.8)
propTestMdd(800,200,0.52,power = 0.8)
propTestMdd(200,0.52,power = 0.8)
propTestMdd(600,0.52,power = 0.8)
propTestMdd(200,600,0.52,power = 0.8)
propTestMdd(600,200,0.52,power = 0.8)
propTestMdd(200,600,0.52,power = 0.9)
propTestMdd(600,200,0.52,power = 0.9)
propTestMdd(600,200,0.52,power = 0.9,two.sided.direction = "less")
propTestMdd(600,200,0.52,power = 0.9)
propTestMdd(200,600,power = 0.9)
propTestMdd(200,600,power = 0.9,two.sided.direction = "less")
propTestMdd(200,600,power = 0.95)
p <- c(0.8,0.9,0.95)
propTestMdd(200,600,0.52)
propTestMdd(200,600,0.52,power = p)
p <- c(0.8,0.9,0.95)
propTestMdd(200,600,0.52,power = p)
propTestMdd(200,600,0.5,power = p)
propTestMdd(200,600,0.48,power = p)
p <- c(0.8,0.9,0.95)
propTestMdd(200,600,0.5,power = p,two.sided.direction = "less")
propTestMdd(200,600,0.5,power = p,two.sided.direction = "less",sample.type = "two.sample")
propTestMdd(200,600,0.5,power = p,sample.type = "two.sample")
propTestMdd(200,600,0.5,power = p,sample.type = "two.sample",alpha = 0.05)
calc_geometric_mean <- function(x, na.rm = FALSE) {
if(!is.numeric(x)) {
stop("x is not of class 'numeric'; it has class '", class(x),"'.")
}
x %>%
log() %>%
mean(na.rm = na.rm) %>%
exp()
}
calc_geometric_mean(letters)
calc_geometric_mean <- function(x, na.rm = FALSE) {
assert_is_numeric(x)
x %>%
log() %>%
mean(na.rm = na.rm) %>%
exp()
}
calc_harmonic_mean(letters)
calc_geometric_mean <- function(x, na.rm = FALSE) {
assert_is_numeric(x)
x %>%
log() %>%
mean(na.rm = na.rm) %>%
exp()
}
calc_geometric_mean(letters)
install.packages("assertive")
library(assertive)
calc_geometric_mean <- function(x, na.rm = FALSE) {
assert_is_numeric(x)
x %>%
log() %>%
mean(na.rm = na.rm) %>%
exp()
}
calc_geometric_mean(letters)
calc_geometric_mean <- function(x, na.rm = FALSE) {
assert_is_numeric(x)
assert_all_are_positive(x)
x %>%
log() %>%
mean(na.rm = na.rm) %>%
exp()
}
calc_geometric_mean(letters)
calc_geometric_mean <- function(x, na.rm = FALSE) {
assert_is_numeric(x)
assert_all_are_positive(x)
x %>%
log() %>%
mean(na.rm = na.rm) %>%
exp()
}
calc_geometric_mean(letters)
calc_geometric_mean(c(1, -1))
use_first(c(1, 4, 9, 16))
coerce_to(c(1, 4, 9, 16),"character")
calc_geometric_mean <- function(x, na.rm = FALSE) {
assert_is_numeric(x)
if(any(is_non_positive(x), na.rm = TRUE)) {
stop("x contains non-positive values, so the geometric mean makes no sense.")
}
na.rm <- coerce_to(use_first(na.rm), target_class = "logical")
x %>%
log() %>%
mean(na.rm = na.rm) %>%
exp()
}
calc_geometric_mean(1:5, na.rm = 1:5)
R.version.string
R.version.string
Sys.info()[c("sysname","release")]
loadedNamespaces()
session <- function() {
list(
r_version = R.version.string,
operating_system = Sys.info()[c("sysname","release")],
loaded_pkgs = loadedNamespaces()
)
}
session()
library(zeallot)
c(vrsn, os, pkgs) %<-% session()
library(zeallot)
c(vrsn, os, pkgs) %<-% session()
vrsn
os
pkgs
vrsn
os
month_no <- setNames(1:12, month.abb)
month_no
attributes(month_no)
attr(month_no, "names")
attr(month_no, "names") <- month.name
month_no
data(Orange, package = "datasets")
orange_trees
attributes(Orange)
library(dplyr)
orange_trees %>%
group_by(Tree) %>%
attributes()
library(dplyr)
Orange %>%
group_by(Tree) %>%
attributes()
# Use broom tools to get a list of 3 data frames
groom_model <- function(model) {
list(
# Get model-level values
model = glance(model),
# Get coefficient-level values
coefficients = tidy(model),
# Get observation-level values
observations = augment(model)
)
}
# Call groom_model on model, assigning to 3 variables
c(mdl, cff, obs) %<-% groom_model(model)
library(groom)
pipeable_plot <- function(data, formula) {
plot(formula, data)
# Add a "formula" attribute to data
attr(data,"formula") <- formula
invisible(data)
}
# From previous exercise
plt_dist_vs_speed <- cars %>%
pipeable_plot(dist ~ speed)
# Examine the structure of the result
str(plt_dist_vs_speed)
datacamp_lst <- list(
name = "DataCamp",
founding_year = 2013,
website = "https://www.datacamp.com"
)
ls.str(datacamp_lst)
datacamp_env <- list2env(datacamp_lst)
ls.str(datacamp_env)
parent <- parent.env(datacamp_env)
environmentName(parent
parent <- parent.env(datacamp_env)
environmentName(parent)
grandparent <- parent.env(parent)
environmentName(grandparent)
search()
datacamp_lst <- list(
name = "DataCamp",
website = "https://www.datacamp.com"
)
datacamp_env <- list2env(datacamp_lst)
founding_year <- 2013
exists("founding_year", envir = datacamp_env)
exists("founding_year", envir = datacamp_env, inherits = FALSE)
3 %>% extract(4)
library(magrittr)
13 %>% extract(2)
c(2,3) %>% extract(2)
c(2,3)[2]
library(magrittr)
c(2,3) %>% extract(2)
c(2,3)[2]
c(10,11) %>% extract(2)
c(10,11)[2]
# View the corn dataset
glimpse(corn)
?facet_wrap
library(mgcv)
?mgcv
q("yes")
